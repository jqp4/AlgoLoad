\section{Construction of the architecture and algorithm of operation of the AlgoView system, software implementation}

\subsection{AlgoView system operation diagram}

The application consists of many steps that occur automatically. Let's consider the sequence of system actions, starting from loading into the system a file describing the information structure of the algorithm in the Algolang language, to obtaining an interactive 3D model of the information graph of this algorithm.

\textbf{Operation of the computational subroutine.} As input data, the system accepts a description of algorithms in the Algolang language in XML format. Next, the source file is converted into JSON format. The next step, using the RapidJSON library, is to create a DOM tree structure in memory, through which all the data in the original XML file can be accessed. This structure is traversed in order to collect all information about the graph into program classes with performing some intermediate calculations for ease of use, namely, calculating ranges of iteration space values. To calculate the values of these expressions, the ExprTk library is used. It is impossible to calculate all the expressions available in the description of the algorithm at this stage, since they depend on the current values of the iteration space and will be calculated in the future. When traversed, such expressions are stored as strings without modification as attributes of the class instance. After collecting all the data from the input file and carrying out preliminary processing, the main loop is launched, performing the meaningful work of the entire program. Inside it, a passage takes place throughout the entire iteration space, calculations are carried out that depend on its current values, the coordinates of the vertices are formed, their level of parallel form is determined \cite{m41}, and the vertices connected by an information edge are determined.

Based on the results of this stage, lists of instances of classes of vertices and edges with a description of their properties, general information about the graph and/or lists of warnings and errors (if any) are generated. Next, based on this information, a file with a JSON structure is generated as an intermediate data format, which is subsequently used to build an interactive 3D visualization.

\textbf{Operation of the visualization subroutine.} After creating the intermediate file, the user receives a web page with a visualization application that starts automatically after downloading. The first step is that the program converts the data from a JSON structure with intermediate data and composes the internal structure of the graph from them. Next, a 3D representation of the graph is created in the form of a set of 3D objects that correspond and visually describe all the structural elements of the graph. The last stage is the construction of an interactive visualization of the resulting set of 3D models, forming, together with the user interface, a multifunctional analysis system.

\subsection{Stages of the computational subroutine}

First, let's make a few disclaimers. In the process of describing the operation of the computational part of the visualization system, the used concept of a parallel form of an information graph will imply precisely the canonical NPL of this graph. The information graph of the algorithm, constructed as a result of the program, is not such in its classical sense, since it also contains vertices with input data, which contradicts the definition in which only the operations of the algorithm are vertices. That is, the concept of a graph used within the framework of the implemented program is, as it were, an epigraph formed by adding vertices with input data to the graph of the algorithm. There is also a restriction imposed on the input data, namely, for algorithm blocks (the \texttt{block} tag in the Algolang language) that describe the support polytopes of its graph, a restriction is imposed on no more than three-dimensional dimensions.

\textbf{Convert to JSON.} At the first stage of work, the XML file is instantly converted into JSON using the small xml2json library. Thus, an error handled by this step can only be an incorrect XML file structure.

\textbf{Collect input data.} The input collection phase uses the DOM API provided by the RapidJSON library to traverse the input file. The library was chosen due to its safer way of accessing the vertices of the DOM tree, built on the basis of XML, which eliminated the problems of jumping to a null pointer that arose with the Algolang language. As a result of traversing the DOM tree, program classes are created that contain all the necessary information about the information structure of the algorithm. The library also has built-in error handling tools, which were used to implement input data validation (for example, reusing an argument name within one block, setting incorrect argument boundaries, etc.).

\textbf{Evaluate mathematical and conditional expressions.} The ability to evaluate mathematical and conditional expressions is necessary to process the expressions described in the input data. The ExprTk library was chosen as a tool for these purposes, which is easily integrated into projects and offers a large base of processed functions and operations, and also quickly performs calculations. All calculations in the program are carried out by one separate function, which takes as input an expression in the form of a string and a map of the names and values of the parameters involved in the calculation.

\textbf{Main loop.} The so-called “Main loop” of the program carries out its content and forms program classes with final information about the algorithm graph model, which need only be rewritten in some standard form for further visualization. The operation of the “Main loop” implements the processing of one block of the algorithm; accordingly, this fragment of the program also works in a loop for all blocks. When a block is submitted for processing as a program class with all the information about it, a field of id numbers of the vertices of the future information graph is created based on the ranges of the iteration space and the shift of all coordinates along one axis is determined depending on the dimension of the previous block, so that the blocks do not overlap each other on a friend. At each iteration step, the current coordinate value is selected. Next, the cycle checks the conditions for the existence of vertices using the function of calculating mathematical expressions for these coordinates. If the condition is met, then a vertex is created for these values, which is assigned the next ordinal id and, based on the information obtained from the description in the Algolang language, its type, or, if the type was not specified, then it is assigned a default value. After this, all source vertices from which the edge leads to the current one are processed. It is checked whether this vertex exists by searching for it in the field of id-numbers of the vertices of the block to which it belongs, at the given coordinates. If such a vertex does not exist, then it is not an operation of the algorithm, but indicates a dependence on the input data. Such a vertex is created with a specially defined type of input data (type "0") and the level value of the parallel form of this vertex is assigned zero. If such a vertex existed, then from its coordinates the program obtains id, also referring to the field of vertices. After this, for each source vertex, based on its id and the id of the current vertex, an edge is created. After processing all source vertices, for the current vertex it is possible to determine the level of its parallel shape. Then the next iteration of the loop occurs.

\textbf{Generation of intermediate output data.} As a result of the operation of the “main loop”, the program generates a list of objects of program classes of vertices and edges with a description of their properties. Based on these lists, output data is generated in JSON format. Thus, the output of the implemented program is a list of vertices and edges with a listing of their properties, a listing of graph properties, and a listing of errors and/or warnings (if any). For Vertices - this is id, coordinates, type and level of the parallel form, for edges - id, id of the vertices that it connects, with the direction from the first named vertex to the second, and type, for a graph - the number of vertices and edges, the length of the critical paths and width of parallel form.

\textbf{Calculation of parallel form.} One of the most important capabilities of the system is to display the membership of groups of vertices to levels in a parallel form. This allows you to analyze which operations of the algorithm can be performed independently of each other (in parallel, in one time). The determination of the parallel form level for each vertex occurs, as mentioned earlier, within the framework of the “Main loop” according to the following principle:

\begin{enumerate}
    \item When creating a new vertex, the default value is level 0 of the tier-parallel form, which means that it does not belong to any tier, that is, it is not an operation (this type of vertex is the input data vertex)
    \item It is determined whether a given vertex is an operation or an input data, and in the second case it is assigned level 1 of the parallel form
    \item Data is collected on the level of the parallel form of all source vertices, if any, and the level of the current vertex is calculated using the formula
    $$ level = \max\left\{level(v): v \in source\_vertices\right\} + 1 $$
\end{enumerate}

\textbf{Analyze the graph to generate a list of errors and warnings.} The system is capable of analyzing and processing three types of errors. System critical errors notify the user that a system error has occurred and he cannot influence the result of the program. This type of error occurs rarely and is intended for the developer. Custom critical errors notify the user why the input data cannot be processed. The user can change the contents of the input files to eliminate errors. Non-critical errors resulting from the operation of the visualization system return a graph constructed in accordance with the XML description of the graph, but with the possible presence of errors in it, about which the user receives a warning.

\textbf{The principle of arrangement of vertices and edges in space.} To locate the vertices and edges of the information graph of the algorithm in three-dimensional space, the following principle was chosen. A three-dimensional Cartesian coordinate system and a fixed-size grid on it are introduced, depending on the range of values of the iteration space. Further, any vertex of the algorithm graph is located in a unique grid node and is specified by the coordinates of this node. Any edge is defined by a pair of grid nodes - its beginning and end. In this way, any information graph of the algorithm can be displayed in three-dimensional space without overlapping vertices. To determine whether a vertex belongs to the level of a parallel form, means of interactive visualization of the final model are used.

\subsection{A software architecture for the visualization task}

One of the main tasks when implementing a system in software is the selection and development of a suitable application architecture. The chosen architecture determines the way data is processed and communicates with the user. Choosing an inappropriate structure and methods for communicating application modules with each other can significantly increase the load on the browser kernel and the operating system's computing resources. Let's consider the main modules of the visualization system to solve this problem:

% 1. Working with data, reading and creating the internal structure of the graph.
% 2. Working with the graph structure based on the view parameters specified by the user. Creation of 3D models for each object in the graph structure.
% 3. Creation of a 3D scene containing a graph model.
% 4. Working with the user: ensuring communication of the control panel with the graph model, scene and parameters and view.
% 5. When changing view parameters, the data in the model must change locally and consistently update the structure of the graph and the 3D model representing this graph on the stage.

\begin{enumerate}
    \item Working with data, reading and creating the internal structure of the graph.
    \item Working with the graph structure based on the view parameters specified by the user. Creation of 3D models for each object in the graph structure.
    \item Creation of a 3D scene containing a graph model.
    \item Working with the user: ensuring communication of the control panel with the graph model, scene and parameters and view.
    \item When changing view parameters, the data in the model must change locally and consistently update the structure of the graph and the 3D model representing this graph on the stage.
\end{enumerate}

The described requirements and main functional parts are sufficient criteria for choosing a Model-View-Controller (MVC) architecture \cite{m45}.

\textbf{Description of the MVC architecture used.} MVC architecture is a pattern for software implementation that divides the application's data handling, user interface, and control logic into three interconnected independent components. The Model represents the data and business logic of the application, the View represents the presentation layer of the application, and the Controller acts as an intermediary between the Model and the View, processing user input and updating the Model and View as needed. When the user interacts with the application, the controller receives the input and decides how to update the model and view accordingly. The Model is responsible for processing the data and updating itself, and the View displays the data to the user in a presentable format. This architecture helps break complex applications into smaller, more manageable components, making the application easier to develop, test, and maintain \cite{m46}.

\textbf{Separation of responsibilities between modules of the AlgoView visualization system.} In the AlgoView visualization system under consideration, the MVC architecture used consists of a model (Model) with a graph structure, a display part (View) with a set of methods for converting data into 3D models, and a controller (Controller) containing methods for changing the model and updating visualization through the user interface. Having chosen an architecture, you need to correctly distribute tasks and responsibilities between application modules, following the rules of a specific architecture. Let's consider how responsibility is distributed in this case:

\textit{Contents of the Model module}: processing of input data; storing the internal structure of the graph; updating data in the graph structure based on user commands.

\textit{Contents of the View module}: providing a set of methods for converting data into 3D models; filling the scene with 3D models obtained from graph objects stored in Model.

\textit{Contents of the Controller module}: creation of a graphical user interface; ensuring communication between the user, his commands through the control menu and the Model-View link; managing Model and View through their built-in control methods.