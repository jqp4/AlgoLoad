1. Введение
Система AlgoView позволяет составить информационный граф алгоритма [1], на основе его описания на языке Algolang [2]. Система создает интерактивную 3D модель заданного алгоритма и предоставляет возможности по его анализу [3]. Такой функционал обеспечивает активное применение системы в образовательных и исследовательских целях [4].
Автоматизированная система визуализации призвана обеспечить визуальное представление внутренней структуры алгоритма, облегчить процесс детального анализа алгоритма и освободить от необходимости вручную выполнять визуализацию алгоритма, обеспечивая исследователям возможность сосредоточиться на анализе алгоритма. Для достижения этих целей интерактивная 3D модель графа алгоритма содержит вспомогательную информацию, обеспечивающую максимальную наглядность принадлежности дуг отдельным вершинам и общей логической структуры алгоритма. Это позволяет работать с системой визуализации и тем, кто не имеет опыта в области применения интересующего алгоритма.
В данной статье описана разработка новой версии системы AlgoView. Произведен обзор существующих решений для построения вычислительной части и способов интерактивной 3D визуализации с возможностями анализа.
2. Постановка задачи
2.1. План работы
Целью проекта является исследование современных методов и разработка новой версии системы AlgoView. Требуется провести исследования для реализации вычислительной составляющей системы. Так же требуется провести исследование современных методов 3D визуализации и разработать автоматизированную систему визуализации графов алгоритмов. Для достижения поставленных целей необходимо пройти многоэтапный процесс исследований и разработки и выполнить следующие задачи:
Изучить понятие информационного графа алгоритма, его свойства и способы применения и анализа, изучить способы описания графа алгоритма. Рассмотреть синтаксис языка Algolang, предназначенного для описания информационной структуры алгоритма в виде XML-файла. По возможности сделать язык Algolang более универсальным.
Изучить возможные методы обработки и программные библиотеки для работы с информационными структурами формата XML, а так же способы вычисления математических выражений, задаваемых в текстовом виде, используемых при описании информационных графов алгоритмов.
Разработать программные методы для обработки необходимой информации об алгоритме из описания на языке Algolang.
Разработать новый формат хранения данных об алгоритме, на основе которого информационный граф может быть визуализирован без дополнительных вычислений с целью получения необходимой информации о структуре графа.
Реализовать программный алгоритм, который на основе информации, полученной из описания алгоритма на языке Algolang, составляет описание модели многомерного графа по новому формату, по которой он может быть визуализирован. Модель должна представлять собой описание расположения вершин и дуг графа в пространстве, а также характеристики информационного графа и свойства каждого элемента этого графа.
Сформировать архитектуру приложения и понятия внутреннего представления графа алгоритма в системе визуализации AlgoView.
Создание программного средства, преобразующего промежуточное представление графа алгоритма формата JSON в множество 3D моделей.
Реализация программного обеспечения, производящего интерактивную 3D визуализацию множества сформированных объектов, представляющих собой граф алгоритма.
Создание web-страницы, на которой производится визуализация и взаимодействие с интерфейсом.
2.2. Промежуточный формат данных
Система Algoview разделяется на вычислительную часть и задачу визуализации. Для автоматизации работы системы требуется разработка нового формата хранения данных об алгоритме. В качестве стандартизированного представления графа алгоритма выступает JSON структура, содержащая характеристики информационного графа алгоритма, информацию о координатах и типе вершин, и информацию о связанности этих вершин через их уникальные идентификаторы. Разработанная структура данных имеет следующий вид (пример из трех вершин и 2 дуг):

Fig. 1: JSON структура, пример исходного формата данных и пример визуализации этого графа.
2.3. [Глеб] Стандарт визуализации графов алгоритмов
Стандарт визуализации графов алгоритмов — стандарт, впервые описанный как руководство, состоящее из набора правил, в соответствии с которыми рекомендуется изображать граф алгоритма. Существование стандарта обуславливается потребностью в построении изображений графов алгоритмов в общепринятом виде, который будет понятен вне зависимости от инструментов, используемых для изображения графа [5]. С появлением системы AlgoView, как универсального способа генерации изображений графов алгоритмов, многие положения в стандарте требуют пересмотра. Нововведения в стандарте касаются автоматизации процесса и ослабления строгости требований к изображению графов.
3. Исследование методов и построение решения
3.1. [Тамара] Обзор существующих решений обработки файлов формата XML
Синтаксические анализаторы SAX и DOM.
Существует два основных подхода анализа файлов формата XML - DOM и SAX API (Application Programming Interface).
DOM анализаторы осуществляют обработку XML-файла, предварительно загрузив данные этого файла в программу в виде DOM (Document Object Model) дерева [6]. Оно является представлением HTML-документа в виде дерева тегов.
SAX (Simple API for XML) анализаторы, в свою очередь, осуществляют поточную событийную обработку XML-документов, не загружая данные во внутренние структуры программы [7].
В качестве целевого варианта рассматривались библиотеки, предлагающие DOM API, поскольку в рамках данной работы потоков обработка не требуется.
Библиотеки, предоставляющие DOM API для обработки XML-файлов.
Наиболее используемыми для языка C++ библиотеками, предоставляющими DOM API, являются RapidXML, PugiXML, TinyXML [9].
RapidXML в основном ориентирован на уменьшение времени выполнения и представляет собой стабильный и быстрый парсер, работающий со скоростью приближающейся к скорости работы функции strlen (функция подсчёта длины в байтах), выполняемой на тех же данных [10].
PugiXML — это библиотека, которая предоставляет программный интерфейс DOM с широкими возможностями обхода/модификации, чрезвычайно быстрый синтаксического анализатор, и возможность доступа к данным по заданному пути [11].
TinyXML — это минимальная версия для анализа данных XML-файлов, не такая быстрая, как две предыдущие. Данная библиотека была создана из соображений простоты в использовании и освоении, и хорошо подходит в том случае, если большая скорость выполнения не является приоритетным фактором при выборе инструментов для работы [12].
Компилятор привязки данных.
Помимо SAX и DOM анализаторов существует способ обработки при помощи компилятора привязки данных XSD Schema. Такой способ был предложен компанией CodeSynthesis, как альтернативное решение обработки XML-файлов с некоторыми преимуществами по сравнению с традиционными подходами [14]. При наличии спецификации экземпляра XML (XML-схема) он генерирует классы C++, представляющие заданный словарь, а также код синтаксического анализа и сериализации XML. По сравнению с API-интерфейсами, такими как DOM и SAX, привязка данных XML позволяет пользователю получать доступ к данным в XML-документах, используя сгенерированный доменный словарь, а не общие элементы, атрибуты и текст.
Дополнительные решения для обработки XML-файлов.
Помимо способов работы напрямую с XML-файлами существует возможность осуществления тех же действий (доступ/анализ/обработка) с данными, только предварительно осуществив конвертацию XML формата к JSON (JavaScript Object Notation) — стандартному текстовому формату обмена данными. В таком случае для обработки данных уже используются библиотеки для работы с форматом JSON, самой используемой из них является RapidJSON.
Важным в рамках данной работы оказался способ представления данных при работе с программным интерфейсом DOM. RapidJSON работает с сущностью Value, которая может быть двух типов — Object и Array. С точки зрения исходного XML-файла — все его теги являются объектами и все одноимённые теги объединяются в массивы. Таким образом, древовидная структура, в виде которой данные хранятся в программе, у библиотеки RapidJSON отличается от структур библиотек, работающих напрямую с форматом XML [15]. И тогда обход этой древовидной структуры, а в частности переход между разноимёнными тегами, расположенными на одной глубине, отличается и представляется более удобным и безопасным с точки зрения доступа к памяти.
3.2. [Тамара] Обзор библиотек для вычисления значений математических выражений
В рамках работы системы визуализации существует необходимость вычисления и оценки математических выражений, с помощью которых описывается информационная структура алгоритма. Для этих целей на языке C++ существует набор внедряемых в проекты сторонних библиотек с открытым кодом. Самыми используемыми и подходящими в рамках данной работы являются ExprTk, muParser, METL (Math Expression Toolkit Library).
Библиотека ExprTk.
ExprTk является наиболее полной и используемой библиотекой для разбора и оценки математических выражений из приведённых выше. Механизм синтаксического анализа поддерживает множество форм функциональной и логической семантики обработки и легко расширяется. Библиотека ExprTk позволяет работать со скалярными, строковыми и векторными типами  данных с числовыми типами Float, Double и MPFR (multiple-precision floating-point) и поддерживает обработку различных математических операций и функций [17]. ExprTk работает по принципу разбора выражения в AST дерево, что позволяет оценить его значение. Согласно тестам производительности, библиотека считается самым быстрым решением для вычисления стандартных операций со скалярными значениями.
Серия библиотек muParser.
MuParser — это серия расширяемых высокопроизводительных библиотек, предоставляющих пользователю разные возможности в зависимости от его нужд [19]. Для достижения большей скорости работы со скалярными значениями с ограничением на количество и тип используемых параметров и точность вычислений используется библиотека muparserSSE. Для преодоления данных ограничений с увеличением времени работы используется muparser. Для работы с векторными и строковыми типами данных и комплексными числами применима версия библиотеки muparserX.
Библиотека METL.
Math Expression Toolkit Library — небольшая библиотека для стандарта языка c++14 для анализа математических выражений. Она спроектирована таким образом, чтобы быть достаточно гибкой, но и то же время эффективной. Под гибкостью подразумевается, что выражения могут использовать все типы переменных с разумным поведением (например, полезно для работы с векторами и матрицами) и при этом добавление и редактирование операторов и функций очень просто.
Сравнение библиотек.
Для библиотек осуществлено сравнение с помощью тестов производительности, разработанных для тестирования корректности вычислений и скорости работы библиотек для парсинга математических выражений, написанных на языке C++ и работающих по принципу POEM (Parse Once Evaluate Many times) [22]. По результатам замеров времени вычислений лидерами среди библиотек для парсинга математических выражений являются muparserSSE и ExprTkFloat, работающие с типом данных Float, а с учётом также точности вычислений - ExprTk, работающая с типом данных  Double [22].
3.3. [Глеб] Исследование методов 3D визуализации
Трехмерная визуализация — важный аспект взаимодействия с пользователем при разработке программного обеспечения. В настоящее время проводится много исследований в области визуализаций графов [23][24][25][26]. Однако анализ производительности алгоритмов с использованием информационных графов не является достаточно популярной областью в науке и не содержит устоявшиеся методов. Для понимания способов реализации проекта требуется дополнительное рассмотрение популярных технологий трехмерной визуализации, доступных на сегодняшний день. В ходе исследования доступных методов 3D-визуализации, были рассмотрены около 10 различных решений: OpenGL [28], WebGL [29][30][31], Three.js [32][33], Babylon.js [34], VTK (Visualization Toolkit) [35], OpenSceneGraph [36], DirectX [37], Unity [38], Blender [39], Maya [40].
После сравнительного анализа инструментов визуализации был сделан вывод, что самые простые и удобные методы визуализации графов реализованы во фреймворках Three.js, Babylon.js, а также на платформе Unity. Итоговый выбор был сделан в пользу фреймворка Three.js, за счет своей легковесности и кроссбраузерности. Для контроля над сценой был использован модуль OrbitControls. Данный модуль является самым распространенным и поддерживаемым решением для реализации управления при помощи компьютерной мышки и клавиатуры [43]. Для создания пользовательского интерфейса и меню управления с возможностями дополнительного анализа графов алгоритмов был использован легковесный модуль dat.GUI [44]. Размер библиотеки со всеми дополнительными модулями пользовательского интерфейса не превышает 1 мегабайта.
3.4. [Глеб] Метод изгиба дуг в трехмерном пространстве
Показатель необходимости изгиба дуг.
Главным сигналом необходимости изгиба дуги возникает при пересечении вершины прямой дугой, так как в этом случае часто непонятно, откуда и куда выходит дуга. Пересечение разных дуг или прохождение дуги через оболочку 3D объекта вершины в среднем не создают проблем с визуальным восприятием информационного графа.
Математический смысл изгиба дуги.
Пусть в трехмерной декартовой системе координат $\Phi$ с базисными векторами $\overrightarrow{i}, \overrightarrow{j}, \overrightarrow{k}$имеется 2 вершины: $A(x_1; y_1; z_1)$ и $B(x_2; y_2; z_2)$. Обозначим длину вектора $\overrightarrow{AB}$ как $len = \sqrt{ (x_2 - x_1)^2 + (y_2 - y_1)^2 + (z_2 - z_1)^2 }$. Пусть между вершинам $A$ и $B$ есть отрезок, которую требуется геометрически изогнуть. Изгибая дугу между вершинами можем представить что вектор $\overrightarrow{AB}$ является одним из базисных векторов другой трехмерной декартовой системы координат $\Psi$, в который нам требуется описать уравнение кривой, исходящей из точки $A(0; 0; 0)$, то есть начала координат, и приходящей в точку $B\left(len; 0; 0 \right)$, удаленную от начала координат на расстояние $len$. После описания уравнения кривой можно перейти к изначальному базису, позиционирующему кривую в пространстве так, чтобы она соответствовала вершинам $A$ и $B$ в изначальной системе координат $\Phi$.
Геометрический метод нахождения базиса.
Вектор $\overrightarrow{AB}$ в трехмерной системе координат $\Phi$ соответствует отрезку $AB$ и является одним из базисных векторов в системе координат $\Psi$. Вычислим первый единичный базисный вектор $\overrightarrow{n_1}$:
$$ \overrightarrow{n_1} = \frac {\overrightarrow{AB}} {\left|\overrightarrow{AB}\right|} $$
Для нахождения второго единичного базисного вектора $\overrightarrow{n_2}$ воспользуемся геометрическими и тригонометрическими методами:
$$ b = \frac {\left|y_{n_1}\right|} {\tg( \frac{\pi}{2} -\sin(\left|x_{n_1}\right|) )}; \quad \gamma = \arctg\left( \left| \frac{z_{n_1}}{x_{n_1}} \right| \right); $$
$$ \overrightarrow{n_2} = \left\{ -b\cos(\gamma) \frac{x_{n_1}} {\left|x_{n_1}\right|}; \quad y_{n_1}; \quad -b\sin(\gamma) \frac{z_{n_1}} {\left|z_{n_1}\right|} \right\} $$
Для нахождения третьего единичного базисного вектора $\overrightarrow{n_3}$ используем векторное произведение:
$$ \overrightarrow{n_3} = \overrightarrow{n_1} \times \overrightarrow{n_2} $$
Единичные вектора $\{\overrightarrow{n_1}, \overrightarrow{n_2}, \overrightarrow{n_3}\}$ образуют базис трехмерной декартовой системы координат $\Psi$.
Метод изгиба дуг через параметрически заданную окружность.
Изгиб дуги при помощи нахождения параметрического уравнения кривой происходит в вышеописанной трехмерной декартовой системе координат $\Psi$. Оптимальным видом изогнутой дуги является часть окружности, ограниченная точками $A(0; 0; 0)$, $B\left(len; 0; 0 \right)$. Для получения искомой дуги достаточно воспользоваться стандартным методом нахождения уравнения окружности по заданному центру и радиусу.
$$ x = R\cos\theta + x_{center}; \quad y = R\sin\theta + y_{center} $$
Радиус описываемой окружности $R$ имеет линейную зависимость от величины расстояния $len$. Центр окружности $C(x_{center}; y_{center}; 0)$ и диапазон значений параметра $\theta$ вычисляются геометрически.
4. Построение архитектуры и алгоритм работы системы AlgoView, программная реализация
4.1. Схема работы системы AlgoView
Работа приложения состоит из множества шагов, которые протекают автоматически. Рассмотрим последовательность действий системы, начиная с загрузки в систему файла с описанием информационной структуры алгоритма на языке Algolang, до получения интерактивной 3D модели информационного графа данного алгоритма.
Работа вычислительной подпрограммы.
В качестве входных данных система принимает описание алгоритмов на языке Algolang в формате XML. ****Далее происходит конвертация исходного файла в формат JSON. Следующим этапом, при помощи средств библиотеки RapidJSON, в памяти создаётся древовидная структура DOM, по которой возможен доступ ко всем данных первоначального XML файла. По данной структуре производится обход с целью сбора всей информации о графе в программные классы с выполнением некоторых промежуточных вычислений для удобства использования, а именно осуществление вычисления диапазонов значений пространства итераций. Для подсчёта значений данных выражений используется библиотека ExprTk. Вычисление всех имеющихся в описании алгоритма выражений на данном этапе невозможно, поскольку они обладают зависимостью от текущих значений пространства итераций и будут вычисляться в дальнейшем. Такие выражения при обходе сохраняются в виде строк без изменений в качестве атрибутов экземпляра класса. После сбора всех данных входного файла и проведения предварительной обработки, запускается основной цикл, выполняющий содержательную работу всей программы. Внутри него происходит проход по всему пространству итераций, осуществляются вычисления, зависимые от текущих его значений, происходит формирование координат вершин, определение их уровня ярусно-параллельной формы [41] и определение вершин, связанных информационной дугой.
По результатам работы этого этапа формируются списки экземпляров классов вершин и дуг с описанием их свойств, общая информация о графе и/или списки предупреждений и ошибок (при наличии). Далее, на основе этой информации, формируется файл с JSON структурой в качестве формата промежуточных данных, который используется в дальнейшем для построения интерактивной 3D визуализации.
Работа подпрограммы визуализации.
После создания промежуточного файла, пользователь получает веб-страницу с приложением визуализации, которое запускается автоматически после загрузки. Первым шагом программа преобразовывает данные из JSON структуры с промежуточными данными и составляет из них внутреннюю структуру графа. Далее производится создание 3D представления графа в виде множества 3D объектов, соответствующих и визуально описывающих все структурные элементы графа. Последним этапом является построение интерактивной визуализации полученного набора 3D-моделей, образуя вместе с пользовательских интерфейсом многофункциональную систему анализа.
4.2 Этапы работы вычислительной подпрограммы
Для начала сделаем несколько оговорок. В процессе описания работы вычислительной части системы визуализации используемое понятие ярусно-параллельной формы информационного графа будет подразумевать именно каноническую ЯПФ этого графа. Информационный граф алгоритма, построенный в результате работы программы не является таковым в классическом его понимании, поскольку содержит в себе также и вершины с входными данными, что противоречит определению, в котором вершинами являются только операции алгоритма. То есть понятие графа, используемое в рамках реализованной программы, является как бы надграфом, образованным путём добавления к графу алгоритма вершин с входными данными. Также существует ограничение, накладываемое на входные данные, а именно для блоков алгоритма(тег <block> на языке Algolang), описывающих опорные многогранники его графа, наложено ограничение не более чем трёхмерной размерности.
Конвертация в JSON.
На первом этапе работы происходит мгновенная конвертация XML-файла в JSON с помощью небольшой библиотеки xml2json. Таким образом, ошибкой, обрабатывающей этим этапом, может быть только неверная структура XML-файла.
Сбор входных данных.
На этапе сбора входных данных для обхода входного файла применяется предоставленный библиотекой RapidJSON API DOM. Библиотека выбрана в связи с более безопасным способом доступа к вершинам DOM дерева, построенного на основе XML, который исключил возникавшие с языком Algolang проблемы перехода по пустому указателю. В результате обхода DOM дерева создаются программные классы, содержащие всю нужную информацию об информационной структуре алгоритма. Также библиотека имеет встроенные средства для обработки ошибок, с помощью которых была реализована валидация входных данных (например, повторное использование имени аргумента внутри одного блока, заданы некорректные границы аргументов и т.д.).
Вычисление математических и условных выражений.
Возможность вычисления математических и условных выражений необходимо для обработки выражений, описанных во входных данных. Инструментом для этих целей была выбрана библиотека ExprTk, которая легко интегрируется в проекты и предлагает большую базу обрабатываемых функций и операций, а также быстро выполняет вычисления. Все вычисления в программе осуществляются одной отдельной функцией, принимающей на вход выражение в виде строки и карту имён и значений параметров, участвующих в вычислении.
Основной цикл.
Так называемый “Основной цикл” программы осуществляет содержательную её часть и формирует программные классы с итоговой информацией о модели графа алгоритма, которые достаточно переписать в некотором стандартном виде для возможности дальнейшей визуализации.
Работа "Основного цикла" реализует обработку одного блока алгоритма, соответственно данный фрагмент программы также работает в цикле для всех блоков. Когда на обработку подаётся блок, как программный класс со всей информацией о нём, для создаётся поле id-номеров вершин будущего информационного графа на основе диапазонов пространства итераций и определяется сдвиг всех координат по одной оси в зависимости от размерности предыдущего блока, чтобы блоки не накладывались друг на друга. На каждом шаге итерации выбирается текущее значение координат. Далее в цикле проверяются условия существования вершин с помощью функции вычисления математических выражений для этих координат. Если условие выполняется, то для данных значений создаётся вершина, которой присваивается очередной порядковый id и, на основе информации, полученной из описания на языке Algolang, её тип, или, если тип не был указан, то ему присваивается значение по умолчанию. После этого осуществляется обработка всех вершин-источников, из которых дуга ведёт в текущую. Проверяется, существует ли эта вершина, путём поиска её в поле id-номеров вершин блока, к которому она принадлежит, по заданным координатам. Если такой вершины не существует, значит она не является операцией алгоритма, а обозначает зависимость от входных данных. Такая вершина создаётся со специально определённым типом входных данных (тип "0") и значению уровня ярусно-параллельной формы данной вершины присваивается нуль. Если такая вершина существовала, то по её координатам программа получается id, также обращаясь к полю вершин. После этого для каждой вершины-источника, по её id и id текущей вершины, создаётся дуга. После обработки всех вершин-источников, для текущей вершины возможно определение уровня её ярусно параллельной формы. Далее происходит следующая итерация цикла.
Формирование промежуточных выходных данных.
В результате работы “основного цикла” программа формирует список объектов программных классов вершин и дуг с описанием их свойств. На основе этих списков формируются выходные данные в формате JSON. Таким образом, выходные данные реализованной программы представляют собой список вершин и дуг с перечислением их свойств, перечисление свойств графа и перечисление ошибок и/или предупреждений (при наличии). Для Вершин — это id, координаты, тип и уровень ярусно-параллельной формы, для дуг — id, id вершин, которые она соединяет, с направлением от первой названной вершины ко второй, и тип, для графа — количество вершин и дуг, длина критического пути и ширина ярусно-параллельной формы.
Расчет ярусно параллельной формы.
Одной из важнейших возможностей системы является отображения принадлежности групп вершин к уровням ярусно-параллельной форме. Это позволяет анализировать, какие операции алгоритма могут выполняться независимо друг от друга (параллельно, за один так времени). Определение уровня ЯПФ для каждой вершины происходит, как уже упоминалось ранее, в рамках работы “Основного цикла” по следующему принципу:
При создании новой вершины значением по умолчанию является уровень 0 ярусно-параллельной формы, что означает, что она не принадлежит никакому ярусу, то есть не является операцией (таким типом вершин является вершина входных данных)


Определятся, является ли данная вершина операцией или входными данными, и во втором случае ей присваивается уровень 1 ярусно-параллельной формы


Происходит сбор данных об уровне ярусно-параллельной формы всех вершин-источников, если таковые имеются, и вычисляется уровень текущей вершины по формуле

 $$ level = \max\left\{level(v): v \in source\_vertices\right\} + 1 $$


Анализ графа для формирования списка ошибок и предупреждений.
Система способна осуществлять анализ и обработку трёх видов ошибок. Системные критические ошибки оповещают пользователя о том, что произошла системная ошибка и повлиять на результат работы программы он не может. Такой тип ошибок возникает редко и создан для разработчика. Пользовательские критические ошибки оповещают пользователя по какой причине входные данные не могут быть обработаны. Пользователь может изменить содержание входного файлы для исключения ошибки. Некритические ошибки в результате работы системы визуализации возвращают граф построенный в соответствии с XML описанием графа, но с возможным наличием в нём ошибок, о которых пользователь получает предупреждение.
Принцип расположения вершин и дуг в пространстве.
Для расположения вершин и дуг информационного графа алгоритма в трёхмерном пространстве был выбран следующий принцип. Вводится трёхмерная декартова система координат и сетка фиксированного размера на ней, зависящая от диапазона значений пространства итераций. Далее, любая вершина графа алгоритма располагается в уникальном узле сетки и задаётся координатами этого узла. Любая дуга задаётся парой узлов сетки - её началом и концом. Таким способом можно отобразить в трёхмерной пространстве любой информационный граф алгоритма без наложений вершин. Для определения принадлежности вершины к уровню ярусно-параллельной формы используются средства интерактивной визуализации итоговой модели.
4.3. [Глеб] Архитектура ПО для задачи визуализации
Одной из главных задач при программной реализации системы является выбор и разработка подходящей архитектуры приложения. От выбранной архитектуры зависит способ обработки данных и общения с пользователем. Выбор неподходящей структуры и методов общения модулей приложения между собой может значительно повысить нагрузку на ядро браузера и вычислительные ресурсы операционной системы. Рассмотрим основные модули системы визуализации для решения этой проблемы:
Работа с данными, считывание и создание внутренней структуры графа.
Работа со структурой графа, основываясь параметрах вида, задаваемых пользователем. Создание 3D моделей для каждого объекта в структуре графа.
Создание 3D сцены, содержащей модель графа.
Работа с пользователем: обеспечение связи панели управления с моделью графа, сценой и параметрам и вида.
При изменении параметров вида данные в модели должны локально изменяться и последовательно обновлять структуру графа и 3D модели, представляющие этот граф на сцене.
Описанные требования и основные функциональные части являются достаточными критериями для выбора архитектуры Model-View-Controller (MVC) [45].
Описание используемой архитектуры MVC.
Архитектура MVC представляет собой шаблон для реализации программного обеспечения, который разделяет работу с данными приложения, пользовательский интерфейс и логику управления на три взаимосвязанных самостоятельных компонента. Модель (Model) представляет данные и бизнес-логику приложения, Представление (View) представляет уровень представления приложения, а Контроллер (Controller) действует как посредник между Моделью и Представлением, обрабатывая пользовательский ввод и обновляя Модель и Представление по мере необходимости. Когда пользователь взаимодействует с приложением, контроллер получает входные данные и решает, как соответствующим образом обновить модель и представление. Модель отвечает за обработку данных и самообновление, а представление отображает данные пользователю в презентабельном формате. Эта архитектура помогает разбивать сложные приложения на более мелкие, более управляемые компоненты, упрощая разработку, тестирование и обслуживание приложения [46].
Разделение ответственности между модулями системы визуализации AlgoView.
В рассматриваемой системе визуализации AlgoView, используемая архитектура MVC состоит из модели (Model) со структурой графа, части отображения (View) с набором методов преобразования данных в 3D модели и контроллера (Controller), содержащего в себе методы изменения модели и обновления визуализации через пользовательский интерфейс. Выбрав архитектуру, требуется грамотно распределить задачи и ответственность между модулями приложения, следуя правилам конкретной архитектуры. Рассмотрим, как в данном случае распределена ответственность:
Содержание модуля Model: обработка входных данных; хранение внутренней структуры графа; обновление данных в структуре графа по командам пользователя.
Содержание модуля View: обеспечение набором методов преобразования данных в 3D модели; заполнение сцены 3D моделями, полученными из объектов графа, хранящимися в Model.
Содержание модуля Controller: создание графического пользовательского интерфейса; обеспечение связи между пользователем, его командами через меню управления и связкой Model-View; управление Model и View через их встроенные методы контроля.
5. Пример работы системы AlgoView
Разберем пример работы системы на простом алгоритме “Нахождение суммы элементов массива сдваиванием”. ****Метод сдваивания используется в качестве быстрого варианта вычисления длинных последовательностей ассоциативных операций. Элементы на каждом этапе алгоритма разбиваются на пары. В каждой из пар находится сумма составляющих её элементов. На следующем этапе на пары разбиваются уже эти суммы, и т. д. Характеристики алгоритма (для суммирования массива порядка n): общее количество вершин: $n - 1$ ; длина критического пути: $\left\lceil{\log_2n}\right\rceil$; каноническая ширина ЯПФ: $n$.
Последовательная сложность алгоритма. Для вычисления суммы массива, состоящего из $n$ элементов, при любых разложениях $n$ на пары суть алгоритма сводится к простому переставлению скобок в формуле суммирования. Количество операций неизменно и равно $n-1$. Последовательный алгоритм должен быть отнесён к алгоритмам линейной сложности по количеству последовательных операций.
Ресурс параллелизма алгоритма. Для суммирования массива порядка $n$ методом сдваивания в параллельном варианте требуется последовательно выполнить $\left\lceil{\log_2n}\right\rceil$ ярусов с убывающим (от $n/2$ до 1) количеством операций суммирования. При классификации по высоте ЯПФ, таким образом, метод сдваивания относится к алгоритмам с логарифмической сложностью. При классификации по ширине ЯПФ его сложность будет линейной.

Fig. 2: Работа системы AlgoView на примере алгоритма “Нахождение суммы элементов массива сдваиванием” для $n = 8$ от реализации алгоритма на языке Си до итоговой визуализации.
6. Заключение
В статье рассматривается исследование современных методов для разработки новой версии системы трехмерной визуализации и интерактивного анализа информационных графов алгоритмов AlgoView. Система в описанном виде используется для академических занятий студентами магистратуры, демонстрируем работоспособность и полезность для науки и исследования информационных графов алгоритмов. В статье показан полный процесс реализации системы и описание алгоритмов для ее работы. Проведено тестирование системы визуализации на большом количестве примеров для выявления проблем и их исправления. Архитектура системы построена с учетом будущих разработок и дополнительных модификаций. Работа над проектом продолжается в сторону расширения класса алгоритмов, которые система может обработать, и новых способов интерактивного анализа графов.


